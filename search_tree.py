###
# Python module containing classes which implement the search tree to be used
# when performing the 'Massacre' calculation.
# Some classes are adapted from the library of classes provided by the AIMA
# textbook. [https://github.com/aimacode/aima-python]
# Acknowledgement of this will be done when this library has been used
# Otherwise modifications and implementations are done by Edmond Pan (841389)
###

# Import the class representing a board state
from board_state import *
from move import *


class MassacreProblem(object):
    # IMPORTANT NOTE: This class has been adapted from the classes provided
    # by the AIMA textbook and inherits from the object class

    def __init__(self, initial_board):
        """
        A MassacreProblem is specified by the initial board configuration
        :param initial_board: A BoardState object containing the initial config
                              of the problem
        """
        self.initial_board = initial_board

    def moves(self, board_state):
        """
        Returns all the moves that can be executed in the given
        state.
        :param board_state: A BoardState object containing the current state
                            of the board
        :return A list of Move objects that are possible/legal
        """
        pos_moves = generate_moves(board_state)
        return pos_moves

    def result(self, board_state, move):
        """
        Return the BoardState that results from executing the given
        move in the current board state. Move must be one of the possible moves
        generated by self.moves(board_state)
        :param board_state: A BoardState object  representing the current state
        :param move: The move that is performed to generate the next board_state
        :return: A new BoardState object containing the state that results from
                 the performed move
        """
        # Create an instance of a copy of the current board state
        output_state = BoardState(other_state=board_state)
        # Swap pieces
        output_state.move_piece(move)
        # Eliminate pieces
        output_state.eliminate_piece()
        return output_state

    def goal_test(self, board_state):
        """
        :param board_state: The BoardState object to check if it is a goal
        :return True if the state is a goal.
        """
        if isinstance(board_state, BoardState):
            # Define a reached_goal(board_state) function here to test if the
            # current board_state contains the requirements to be a goal
            if len(board_state.search_board('B')) == 0:
                return True
        else:
            # It isn't a proper board state so it cannot be a valid goal
            return False

    def path_cost(self, c, state1, action, state2):
        """Return the cost of a solution path that arrives at state2 from
        state1 via action, assuming cost c to get up to state1. If the problem
        is such that the path doesn't matter, this function will only look at
        state2.  If the path does matter, it will consider c and maybe state1
        and action. The default method costs 1 for every step in the path."""
        return c + 1


class Node:
    # IMPORTANT NOTE: This class has been adapted from the classes provided
    # by the AIMA textbook
    """
    Class defines a single node in the search tree.
    """
    def __init__(self, board_state, parent=None, move=None, path_cost=0):
        """
        Creates a search tree Node, derived from a parent by an action.
        :param board_state: current state this node represents
        :param parent: A pointer to the parent node
        :param move: The action that was taken to get to this current state
                     stored by the node
        :param path_cost: The path cost to reach this current state
        """
        self.board_state = board_state
        self.parent = parent
        self.move = move
        self.path_cost = path_cost
        self.depth = 0
        if parent:
            # If a parent node exists increase the current depth by 1
            self.depth = parent.depth + 1

    def __lt__(self, node):
        # Function taken directly from AIMA class
        return self.board_state < node.state

    def __str__(self):
        """
        This function defines how to represent a node as a string
        :return: A string
        """
        line = ''
        line += self.board_state.__str__()
        line += self.move.__str__()
        line += '\n'
        return line

    def child_node(self, problem, move):
        """
        Creates a new child node to connect to this node
        :param problem: MassacreProblem object containing the information on
                        how nodes expand
        :param move: A Move object representing the move that will be performed
        :return: A Node object containing the newly created child node
        """
        # Generate the next node
        next_node = problem.result(self.board_state, move)
        # Return a newly created child node with the current node set as its
        # parent
        return Node(next_node, self, move,
                    problem.path_cost(self.path_cost, self.board_state, move,
                                      next_node))

    def expand(self, problem):
        """
        This function lists all the other nodes that are connected to this one
        :param problem: A MassacreProblem object that contains information on
                        how nodes expand
        :return: A list of Node objects that are reachable
        """
        # List comprehension that generates a child node for every possible
        # action in the current state
        return [self.child_node(problem, move)
                for move in problem.moves(self.board_state)]

    def solution(self):
        """
        Return the sequence of actions to go from the root to this node.
        """
        return [node.move for node in self.path()[1:]]

    def path(self):
        """
        Return a list of nodes forming the path from the root to this node.
        """
        node, return_path = self, []
        while node:
            # Add the nodes in reverse order to a list until you reach the
            # root parent node which will terminate the loop
            return_path.append(node)
            node = node.parent
        # Reverse the list to get the proper path back
        return list(reversed(return_path))

    # For our problem we treat 2 nodes as equal if and only if there states
    # are equal

    def __eq__(self, other):
        return isinstance(other, Node) and self.board_state == other.board_state

    def __hash__(self):
        return hash(self.board_state)


class Stack:
    """
    Class that implements a queue using LIFO ordering. To be used for all
    depth first search implementations
    """
    def __init__(self):
        # The basic structure is a Python list as it dynamically resizes itself
        self.stack = list()
        self.history = list()

    def push(self, data):
        """
        This function adds an element to the stack
        :param data: Any bit of data to be added. For our problem this would be
                     a Node object
        :return: None
        """
        # Check if data has been added already
        if data in self.history:
            return
        # Add the next bit of data to the end of the list
        else:
            self.stack.append(data)
            self.history.append(data)
            return

    def pop(self):
        """
        Function to return the last item added into the stack
        :return: The item that was last added to the stack
        """
        # Making sure that the stack is not empty
        if len(self.stack) > 0:
            return self.stack.pop()
        else:
            print("ERROR: Stack is empty!!")
            return

    def size(self):
        """
        Function to return the number of items currently stored in the stack
        :return: An integer corresponding to the number of items in the stack
        """
        return len(self.stack)
